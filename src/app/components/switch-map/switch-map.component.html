<h1>Theory</h1>
<p>We already learned that the `map` operator takes the emitted value of an `Observable` and transforms it into a new value. Often we end up in the scenario, that we want to take the value of an `Observable` and create a new `Observable`. This could happen for example when one wants to use the emitted value of an `Observable` and perform an HTTP request with that data. If we would use the `map` operator in such a scenario we would end up with an `Observable` of `Observables`. To work with `Observables` of  `Observables` RxJS provides different operators that apply flattening mechanisms to end up with a flat `Observable` instead of an `Observable` of `Observables`.

  The `Observable` returned in the `concatMap` function (aka. inner `Observable`) has to complete before new values of the source `Observable` are considered. While the inner `Observable` has not complete yet, all values emitted by the source `Observable` were cached and used as soon as the inner `Observable` completes. As soon as it completes the next emitted value is used to create a new `Observable`. The inner `Observable` must complete, otherwise, the internal cache might exceed.

  `switchMap` works slightly differently. It will unsubscribe from the inner `Observable` as soon as the source `Observable` emits a new value. Besides that, it will also subscribe to the inner `Observable` and return the emitted values by the inner `Observable`.</p>
